[{"path":"/2024/09/05/框架篇/","content":"1.spring框架中的单例bean是线程安全的吗？不是线程安全的 Spring框架中有一个@Scope注解，默认的值就是singleton，单例的 因为一般在spring的bean中都是注入无状态的对象，没有线程安全问题，如果bean中定义了可修改的成员变量，要考虑线程安全问题的，可以使用多例或者加锁来解决 2AOP2.1什么是Aop面向切面编程，用于将那些与事务无关，却对多个对象产生影响的公共行为和逻辑，抽取公共模块复用，降低耦合 2.2你们项目中有没有使用到aop 记录操作日志，缓存，spring实现的事务核心是：使用aop中的环绕通知+切点表达式（找到要记录日志的方法），通过环绕通知的参数获取请求方法的参数（类，方法，注解，请求方式等），获取到这些参数以后，保存到数据库 2.3Spring中的事务是如何实现的其本质是通过aop功能 ，对方法前后进行拦截，再执行方法之前开启事务，在执行完目标方法之后根据执行情况提交或者回滚事务。 3.Spring中事务失效的场景有哪些？ 异常捕获处理，自己处理了异常，没有抛出，解决：手动抛出 抛出检查异常，配置rollbackFor属性改为Exception 非public方法导致的事务失效，改为public 4.Spring的bean的生命周期 通过BeanDefinition获取bean 的定义信息 调用构造函数实例化bean bean的依赖注入 处理Aware接口（BeanNameAware、BeanFactory、ApplicationContextAware） Bean的后置处理器BeanPostProcessor-前置 初始化方法（initializingBean、init-method） Bean的后置处理器BeanPostProcessor-后置 销毁bean 5.1Spring中的循环引用循环依赖：循环依赖其实就是循环引用，也就是两个或两个以上的bean互相持有的对方，最终形成闭环，比如A依赖于B，B依赖于A 循环依赖在spring中是允许存在，spring框架依据三级缓存已经解决了大部分的循环依赖 一级缓存：单例池，缓存已经经历了完整的生命周期，已经初始化完成的bean对象 二级缓存：缓存早期的bean对象（生命周期还没走完） 三级缓存：缓存的是ObjectFactory，表示对象工厂，用来创建某个对象 5.2 构造方法出现了循环依赖怎么解决？A依赖于B，B依赖于A，注入的方式是构造函数 原因：由于bean的生命周期中构造函数是第一个执行的，spring框架并不能解决构造函数的依赖注入 解决方法：使用@lazy进行懒加载，什么时候需要再进行bean对象的创建 6.SpringMVC的执行流程 用户发送出请求到前端控制器DispatcherServlet DispatcherServlet收到请求调用HandlerMapping（处理器映射器） HandlerMapping找到具体的处理器，生成处理器对象及处理器拦截器（如果有），再一起返回给DispatcherServlet DispatcherServlet调用HandlerAdapter（处理器适配器） DispatcherServlet经过适配调用具体的处理器（Handler&#x2F;Controller） 方法上添加了@ResponseBody 通过HttpMessageConverter来返回结果转换为JSON并响应 7.Spring框架的常见注解7.1Spring@component、@Controller、@Service、@Repository 使用在类上用于实例化Bean @Autowired 使用在字段上用于根据类型依赖注入 @Qualifier 结合@Autowired 一起使用用于根据名称进行依赖注入 @Scope 标注Bean 的作用范围 @Configuration 指定当前类是一个Spring配置类，当创建容器时会从该类上加载注解 @ComponentScan 用于指定Spring 在初始化容器时要扫描的包 @Bean 使用在方法上，标注该方法的返回值存储到Spring容器中 @Import 使用@Import导入的类会被Spring加载到IOC容器中 @Aspect、@Before、@After、@Around、@pointcut 用于切面编程（Aop） 7.2SpringMVC@RequestMapping 用于映射请求路径，可以定义在类上和方法上。用于类上，则表示类中的所有的方法都是以该地址作为父路径 @RequestBody 注解实现接收http请求的json数据，将json转换为Java对象 @RequestParam 指定请求参数的名称 @PathViriable 从请求路径下中获取请求参数{&#x2F;user&#x2F;{id}}，传递给方法的形式参数 @ResponseBody 注解实现将controller方法返回对象转换为json对象响应给客户端 @RequestHeader 获取指定的请求头数据 @RestController @Controller+@ResponseBody 8.Mybatis执行流程 读取MyBatis配置文件：mybatis-config.xml加载运行环境和映射文件 构造会话工厂SqlSessionFactory 会话工厂创建SqlSession对象(包含了执行SQL语句的所有方法) 操作数据库的接口,Executor执行器,同时负责查询缓存的维护 Executor接口的执行方法中有一个MappedStatement类型的参数,封装了映射信息 输入参数映射 输出结果映射"},{"path":"/2024/08/31/我的第一篇文章/","content":"dfghjasdbasdasjdsd sdasdasdasdsada"},{"path":"/2024/08/31/test1/","content":"​—title: 测试文章date: 2021-02-31 17:25:40tags:​— 测试文章1 sadsadasda 1System.println.out(&quot;HelloWorld&quot;) ddfashgdhasdjkasbdasjdad ajsd"},{"title":"Hello World","path":"/2024/07/10/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"}]